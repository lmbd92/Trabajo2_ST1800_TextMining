@@2841514 In computational complexity theory , generalized geography is a well-known PSPACE-complete problem . # Introduction # Geography is a children 's game , which is good for a long car trip , where players take turns naming cities from anywhere in the world . Each city chosen must begin with the same letter that ended the previous city name . Repetition is not allowed . The game begins with an arbitrary starting city and ends when a player loses because he or she is unable to continue . # Graph model # To visualize the game , a directed graph can be constructed whose nodes are each cities of the world . An arrow is added from node ' ' N <sub> 1 </sub> ' ' to node ' ' N <sub> 2 </sub> ' ' if and only if the city labeling ' ' N <sub> 2 </sub> ' ' starts with the letter that ending the name of the city labeling node ' ' N <sub> 1 </sub> ' ' . In other words , we draw an arrow from one city to another if the @ @ @ @ @ @ @ @ @ @ rules . Each alternate edge in the directed graph corresponds to each player ( for a two player game ) . The first player unable to extend the path loses . An illustration of the game ( containing some cities in Michigan ) is shown in the figure below . : In a generalized geography ( GG ) game , we replace the graph of city names with an arbitrary directed graph . The following graph is an example of a generalized geography game . : # Playing the game # We define ' ' P ' ' <sub> 1 </sub> as the player moving first and ' ' P ' ' <sub> 2 </sub> as the player moving second and name the nodes ' ' N ' ' <sub> 1 </sub> to ' ' N ' ' <sub> ' ' n ' ' </sub> . In the above figure , ' ' P ' ' <sub> 1 </sub> has a winning strategy as follows : ' ' N ' ' <sub> 1 </sub> points only to nodes ' ' N ' ' <sub> 2 </sub> and ' ' N ' @ @ @ @ @ @ @ @ @ @ ' <sub> 1 </sub> ' s first move must be one of these two choices . ' ' P ' ' <sub> 1 </sub> chooses ' ' N ' ' <sub> 2 </sub> ( if ' ' P ' ' <sub> 1 </sub> chooses ' ' N ' ' <sub> 3 </sub> , then ' ' P ' ' <sub> 2 </sub> will choose ' ' N ' ' <sub> 9 </sub> as that is the only option and ' ' P ' ' <sub> 1 </sub> will lose ) . Next ' ' P ' ' <sub> 2 </sub> chooses ' ' N ' ' <sub> 4 </sub> because it is the only remaining choice . ' ' P ' ' <sub> 1 </sub> now chooses ' ' N ' ' <sub> 5 </sub> and ' ' P ' ' <sub> 2 </sub> subsequently chooses ' ' N ' ' <sub> 3 </sub> or ' ' N ' ' <sub> 7 </sub> . Regardless of ' ' P ' ' <sub> 2 </sub> <span> ' </span> s choice , ' ' P ' ' <sub> 1 </sub> chooses ' ' @ @ @ @ @ @ @ @ @ @ ' ' <sub> 2 </sub> has no remaining choices and loses the game . # Problem statement # The problem of determining which player has a winning strategy in a generalized geography game is PSPACE-complete . Let GG = **14;73288;''G'', ' ' P ' ' <sub> 1 </sub> has a winning strategy for the generalized geography game played on graph ' ' G ' ' starting at node ' ' b ' ' . # Proof # # Generalized geography is in PSPACE # To show that GG PSPACE , we present a polynomial-space recursive algorithm determining which player has a winning strategy . Given an instance of GG , **18;73304;''G'', start </sub> where ' ' G ' ' is a directed graph and ' ' n ' ' <sub> start </sub> is the designated start node , the algorithm ' ' M ' ' proceeds as follows : On ' ' M ' ' ( **18;73324;''G'', start </sub> ) : # Measure the out-degree of node ' ' n ' ' <sub> start </sub> . If this degree is 0 , then return <tt> reject </tt> , because there are @ @ @ @ @ @ @ @ @ @ list of all nodes reachable from ' ' n ' ' <sub> start </sub> by one edge : ' ' n ' ' <sub> 1 </sub> , ' ' n ' ' <sub> 2 </sub> , ... , ' ' n ' ' <sub> ' ' i ' ' </sub> . # Remove ' ' n ' ' <sub> start </sub> and all edges connected to it from ' ' G ' ' to form ' ' G1 ' ' . # For each node ' ' n ' ' <sub> ' ' j ' ' </sub> in the list ' ' n ' ' <sub> 1 </sub> , ... , ' ' n ' ' <sub> ' ' i ' ' </sub> , call ' ' M ' ' ( **21;73344;''G''1'', ' ' j ' ' </sub> ) . # If all of these calls return ' ' accept ' ' , then no matter which decision ' ' P ' ' <sub> 1 </sub> makes , ' ' P ' ' <sub> 2 </sub> has a strategy to win , so return ' ' reject ' ' . Otherwise @ @ @ @ @ @ @ @ @ @ ' ' ) ' ' P ' ' <sub> 1 </sub> has a choice that will deny any successful strategies for ' ' P ' ' <sub> 2 </sub> , so return ' ' accept ' ' . The algorithm ' ' M ' ' clearly decides GG . It is in PSPACE because the only non-obvious polynomial workspace consumed is in the recursion stack . The space consumed by the recursion stack is polynomial because each level of recursion adds a single node to the stack , and there are at most ' ' n ' ' levels , where ' ' n ' ' is the number of nodes in ' ' G ' ' . # Generalized geography is PSPACE-hard # To establish the PSPACE-hardness of GG , we can reduce the FORMULA-GAME problem ( which is known to be PSPACE-hard ) to GG in polynomial time ( P ) . In brief , an instance of the FORMULA-GAME problem consists of a quantified Boolean formula = ' ' x ' ' <sub> 1 </sub> ' ' x ' ' <sub> 2 </sub> ' ' x ' ' @ @ @ @ @ @ @ @ @ @ ' ' ( ) where ' ' Q ' ' is either or . The game is played by two players , ' ' P <sub> a </sub> ' ' and ' ' P <sub> e </sub> ' ' , who alternate choosing values for successive ' ' x <sub> i </sub> ' ' . ' ' P <sub> e </sub> ' ' wins the game if the formula ends up ' ' true ' ' , and ' ' P <sub> a </sub> ' ' wins if ends up ' ' false ' ' . In this proof , we assume that the quantifier list starts and ends with the existential qualifier , , for simplicity . Note that any expression can be converted to this form by adding dummy variables that do not appear in . : By constructing a graph ' ' G ' ' like the one shown above , we will show any instance of FORMULA-GAME can be reduced to an instance of Generalized Geography , where the optimal strategy for ' ' P <sub> 1 </sub> ' ' is equivalent to that of ' ' @ @ @ @ @ @ @ @ @ @ strategy for ' ' P <sub> 2 </sub> ' ' is equivalent to that of ' ' P <sub> a </sub> ' ' . The left vertical chain of nodes is designed to mimic the procedure of choosing values for variables in FORMULA-GAME . Each diamond structure corresponds to a quantified variable . Players take turns deciding paths at each branching node . Because we assumed the first quantifier would be existential , ' ' P ' ' <sub> 1 </sub> goes first , selecting the left node if ' ' x ' ' <sub> 1 </sub> is ' ' true ' ' and the right node if ' ' x ' ' <sub> 1 </sub> is ' ' false ' ' . Each player must then take forced turns , and then ' ' P <sub> 2 </sub> ' ' chooses a value for ' ' x ' ' <sub> 2 </sub> . These alternating assignments continue down the left side . After both players pass through all the diamonds , it is again ' ' P ' ' <sub> 1 </sub> ' s turn , because we assumed that @ @ @ @ @ @ @ @ @ @ ' <sub> 1 </sub> has no choice but to follow the path to the right side of the graph . Then it is ' ' P ' ' <sub> 2 </sub> ' s turn to make a move . When the play gets to the right side of the graph , it is similar to the end of play in the formula game . Recall that in the formula game , ' ' P <sub> e </sub> ' ' wins if is ' ' true ' ' , while ' ' P <sub> a </sub> ' ' wins if is ' ' false ' ' . The right side of the graph guarantees that ' ' P <sub> 1 </sub> ' ' wins if and only if ' ' P <sub> e </sub> ' ' wins , and that ' ' P ' ' <sub> 2 </sub> wins if and only if ' ' P <sub> a </sub> ' ' wins . First we show that ' ' P ' ' <sub> 2 </sub> always wins when ' ' P <sub> a </sub> ' ' wins . If ' ' P @ @ @ @ @ @ @ @ @ @ false ' ' . If is ' ' false ' ' , there exists an unsatisfying clause . ' ' P ' ' <sub> 2 </sub> will choose an unsatisfying clause to win . Then when it is ' ' P ' ' <sub> 1 </sub> ' s turn he must choose a literal in that clause chosen by ' ' P ' ' <sub> 2 </sub> . Since all the literals in the clause are ' ' false ' ' , they do not connect to previously visited nodes in the left vertical chain . This allows ' ' P ' ' <sub> 2 </sub> to follow the connection to the corresponding node in a diamond of the left chain and select it . However , ' ' P ' ' <sub> 1 </sub> is now unable to select any adjacent nodes and loses . Now we show that ' ' P ' ' <sub> 1 </sub> always wins when ' ' P <sub> e </sub> ' ' wins . If ' ' P <sub> e </sub> ' ' wins , is ' ' true ' ' . If is @ @ @ @ @ @ @ @ @ @ right side of the graph contains a ' ' true ' ' literal . ' ' P ' ' <sub> 2 </sub> can choose any clause . Then ' ' P ' ' <sub> 1 </sub> chooses the literal that is ' ' true ' ' . And because it is ' ' true ' ' , its adjacent node in the left vertical node has already been selected , so ' ' P ' ' <sub> 2 </sub> has no moves to make and loses . # Consequences # Given that GG is PSPACE-complete , no polynomial time algorithm exists for optimal play in GG unless P = PSPACE . However , it may not be as easy to prove the complexity of other games because certain games ( such as chess ) contain a finite number of game positions -- making it hard ( or impossible ) to formulate a mapping to a PSPACE-complete problem . In spite of this , the complexity of certain games can still be analyzed by generalization ( e.g. , to an ' ' n ' ' &amp;times ; ' ' n ' ' @ @ @ @ @ @ @ @ @ @ generalized Go , as a corollary of the proof of the completeness of GG. 
